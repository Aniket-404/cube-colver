/**
 * Pattern Debugging Tool
 * Captures actual OLL patterns during failed solves to identify missing database entries
 */

import { createSolvedCube, cloneCubeState } from './utils/cubeStructures.js';
import { getOLLPattern, solveCube3x3, parseMoveNotation3x3, applyMoveSequence3x3 } from './services/solver3x3x3.js';

console.log('ğŸ” Starting Pattern Recognition Debugging...');

/**
 * Test scrambles that generate various patterns
 */
const TEST_SCRAMBLES = [
    "",
    "R",
    "R U",
    "R U R'",
    "R U R' U R U2 R'",  // Known Sune case
    "F R U R' U' F'",    // T-OLL setup
    "U",
    "U R U' R'",
    "R2 U2 R2 U2 R2 U2",
    "R U2 R' D R U2 R' D'",
    "L' U2 L U L' U L",  // Anti-Sune setup
    "r U R' U' r' F R F'", // L-Shape setup
    "R U R' U R U' R' U R U2 R'", // H-OLL setup
    "R U2 R2 U' R2 U' R2 U2 R",  // Pi-OLL setup
    "F U R U' R' F'", // Basic F move
];

/**
 * Debug a single scramble to capture patterns
 */
function debugScramblePatterns(scrambleIndex, scramble) {
    console.log(`\n=== Debug ${scrambleIndex + 1}: ${scramble || '(solved cube)'} ===`);
    
    try {
        // Create test cube and apply scramble
        const testCube = createSolvedCube('3x3x3');
        if (scramble && scramble.trim() !== '') {
            const moves = parseMoveNotation3x3(scramble);
            applyMoveSequence3x3(testCube, moves);
        }
        
        // Get the pattern
        const pattern = getOLLPattern(testCube);
        console.log(`ğŸ“‹ OLL Pattern: ${pattern}`);
        
        // Try to solve with CFOP to see what patterns appear during solving
        const cubeClone = cloneCubeState(testCube);
        
        try {
            const result = solveCube3x3(cubeClone);
            console.log(`ğŸ¯ CFOP Result: ${result.success ? 'âœ… SUCCESS' : 'âŒ FAILED'} (${result.totalMoves} moves)`);
            
            // Log any patterns that were encountered during solving
            if (result.details && result.details.ollInfo) {
                console.log(`ğŸ” OLL Details: ${JSON.stringify(result.details.ollInfo)}`);
            }
        } catch (error) {
            console.log(`âŒ CFOP Error: ${error.message}`);
        }
        
        return {
            scramble: scramble,
            pattern: pattern,
            index: scrambleIndex
        };
        
    } catch (error) {
        console.log(`âŒ Error processing scramble: ${error.message}`);
        return {
            scramble: scramble,
            error: error.message,
            index: scrambleIndex
        };
    }
}

/**
 * Run pattern debugging on all test cases
 */
function runPatternDebugging() {
    console.log('\nğŸ“‹ Debugging OLL Patterns from Test Cases...\n');
    
    const patterns = new Set();
    const results = [];
    
    for (let i = 0; i < TEST_SCRAMBLES.length; i++) {
        const result = debugScramblePatterns(i, TEST_SCRAMBLES[i]);
        results.push(result);
        
        if (result.pattern) {
            patterns.add(result.pattern);
        }
    }
    
    // Summary of unique patterns found
    console.log('\nğŸ“Š PATTERN ANALYSIS SUMMARY\n');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`Total Scrambles Tested: ${results.length}`);
    console.log(`Unique Patterns Found: ${patterns.size}`);
    
    console.log('\nğŸ” ALL DISCOVERED PATTERNS:\n');
    
    const patternArray = Array.from(patterns).sort();
    for (const pattern of patternArray) {
        // Find which scrambles generate this pattern
        const scrambles = results.filter(r => r.pattern === pattern).map(r => r.scramble || '(solved)');
        console.log(`Pattern: ${pattern}`);
        console.log(`  Generated by: ${scrambles.join(', ')}`);
        console.log(`  In database: ${isPatternInDatabase(pattern) ? 'âœ… YES' : 'âŒ NO'}`);
        console.log('');
    }
    
    console.log('\nğŸ’¡ RECOMMENDATIONS:\n');
    console.log('âœ… PATTERNS IN DATABASE:');
    const inDatabase = patternArray.filter(p => isPatternInDatabase(p));
    for (const pattern of inDatabase) {
        console.log(`   â€¢ ${pattern}`);
    }
    
    console.log('\nâŒ MISSING PATTERNS (Need algorithms):');
    const missing = patternArray.filter(p => !isPatternInDatabase(p));
    for (const pattern of missing) {
        console.log(`   â€¢ ${pattern}`);
    }
    
    console.log('\nğŸ”¬ Pattern Recognition Debugging Complete!');
    console.log(`ğŸ“ˆ Database Coverage: ${inDatabase.length}/${patternArray.length} patterns (${((inDatabase.length / patternArray.length) * 100).toFixed(1)}%)`);
    
    return results;
}

/**
 * Check if a pattern is in our current database
 */
function isPatternInDatabase(pattern) {
    const databasePatterns = [
        "11111111", // OLL Skip
        "01111010", // Sune  
        "11011011", // Anti-Sune
        "00011101", // T-OLL & I-Shape
        "10011000", // L-Shape
        "01111011", // H-OLL & Cross OLL
        "01011011"  // Pi-OLL
    ];
    
    return databasePatterns.includes(pattern);
}

// Run the debugging
runPatternDebugging();